# Обзор структур данных из Java Collections Framework

# Краткий обзор структур данных в Java

Классы, предназначенные для использования в общих случаях:

- **List** - ArrayList, LinkedList
- **Deque (Double-ended queue)** - ArrayDeque
- **Map** - HashMap, LinkedHashMap
- **Set** - HashSet, LinkedHashSet

Классы, которые предназначены для использования в специфических случаях:

- **TreeMap/TreeSet** - представляют собой Sorted Map/Sorted Set. Построены на основе *BST*
- **PriorityQueue** - очередь с приоритетом. Построен на основе *Heap*

---

# Обзор интерфейсов и классов структур данных в Java

# Интерфейсы

## List

[List](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html) - это интерфейс, представляющий
собой АТД «Список (List)» и предназначенный для хранения и обхода элементов в порядке вставки.

Есть 2 имплементации листа:

- ArrayList на основе массива
- LinkedList на основе двусвязного списка

Из них нужно использовать ArrayList, так как она более эффективная в плане памяти и утилизации кеша. Однако, если
требуется удалять элементы с начала или в середине списка, то лучше выбрать LinkedList, так как операция удаления в
массиве требует времени O(n) против O(1) в двусвязном списке.

---

## Queue, Stack

- [Queue](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html) - это интерфейс,
  представляющий собой АТД «Очередь (queue)», которая работает по принципу FIFO
- [Stack](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Stack.html) - класс, имплементирующий
  АТД «Стек (queue)». Да-да, это класс, а не интерфейс: в Java нет интерфейса под чистый стек. Более того, этот класс
  очень древний, неэффективный, и вообще не используется на практике

Есть одна прямая имплементация Queue:

- PriorityQueue

Однако, PriorityQueue совершенно не подходит для использования в качестве классической очереди.

Так что же в Java используется в качестве стека или очереди? На самом деле, в Java есть интерфейс, покрывающий оба
случая: это Deque, который наследует интерфейс Queue и предлагает возможности как очереди, так и стека. Да, тут как-то
не красиво совсем получается: в идеале Deque должен был также наследовать интерфейс Stack, но такого интерфейса в Java
нет.

---

## Deque

[Deque](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Deque.html)

Deque - это интерфейс, представляющий собой АТД «Дек (deque)». Deque может использоваться и как стек *LIFO (
Last-in-First-out)*, и как очередь *FIFO (First-in-First-out)*.

Применение Deque:

- Если нужна LIFO или FIFO структура данных

Есть две имплементации дека:

- [ArrayDeque](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayDeque.html)
- [Linked List](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html)

Из них нужно использовать *ArrayDeque*, потому что она наиболее эффективная в плане представления в памяти и утилизации
кэша, так как построена на основе массива.

Полезные методы:

- addFirst, addList - добавить элемент в начало или конец дека соответственно
- peekFirst, pollFirst - если нужно посмотреть или посмотреть и удалить элемент в начале дека соответственно
- peekLast, pollLast - если нужно посмотреть или посмотреть и удалить элемент в конце дека соответственно

---

## Map

[Map](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html) - это интерфейс, представляющий
собой АТД «Ассоциативный массив (Map)».

Map позволяет хранить пары типа \<ключ, значение>.

Существуют такие имплементации мапы:

- HashMap на основе хеширования
- LinkedHashMap, которая наследует HashMap с той разницей, что упорядочивает элементы в порядке их вставки путем
  поддержания двусвязного списка между элементами
- TreeMap, в которой поддерживается отсортированный порядок элементов. Эта мапа очень специфична и ее я разберу далее.

---

## Set

[Set](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html) предназначен для хранения
уникальных значений.

Существуют такие имплементации сета:

- HashSet на основе хеширования. Внутри себя на самом деле поддерживает HashMap, оперируя только ее ключами
- LinkedHashSet, который наследует HashSet с той разницей, что упорядочивает элементы в порядке их вставки. Таким же
  образом, под капотом лежит LinkedHashMap
- TreeSet, в котором поддерживается отсортированный порядок элементов. Построен на основе TreeMap

# Классы

## PriorityQueue

[PriorityQueue](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html) - это класс,
который имплементирует АТД "Очередь с приоритетом" и построен на основе Heap. По-умолчанию в Java это min-heap (
min-priority-queue), однако порядок можно изменить.

Хотя эта структура данных и имплементирует интерфейс Queue, не надо рассматривать эту структуру данных как очередь FIFO,
так как PriorityQueue предназначена для другой цели: поддерживать в голове очереди наименьший или наибольший элемент
согласно некоторому компаратору. Я считаю, что зря вообще этот класс имплементирует интерфейс Queue, ибо на самом деле
это совершенно другой АТД «Очередь с приоритетом».

Эта структура данных не предназначена для обхода элементов, а ее iterator() не гарантирует никакого порядка обхода
элементов.

По-умолчанию PriorityQueue поддерживает в head наименьший элемент, но можно поддерживать и наибольший вот так:

```java
class MaxPriorityQueue {
    PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.<Integer>naturalOrder().reversed());
}
```

---

## TreeMap

[TreeMap](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html) - это мапа с
отсортированным порядком элементов (sorted map), которая построена на основе BST, а точнее Red-Black Tree. В принципе,
ты можешь думать об этом элементе как о структуре данных со всеми достоинствами BST.

Применение:

- Поддерживать отсортированный порядок элементов и обходить их в этом порядке
- Эффективно находить наследника (successor) или преемника (predecessor) указанного ключа

Полезные методы:

- lowerEntry(K), floorEntry(K), ceilingEntry(K) и higherEntry(K) - возвращают соответственно меньший, меньший или
  равный, больший или равный, и больший элемент чем указанный ключ
- subMap(K, boolean, K, boolean) - возвращают сабсет мапы между low и high границей. Boolean параметры указывают,
  inclusive или exclusive границы
- headMap(K, boolean) и tailMap(K, boolean) - возвращают сабсет мапы с ключами, соответственно меньшими или большими чем
  указанный. Boolean параметры указывают, inclusive или exclusive граница
