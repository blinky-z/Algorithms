# Бинарные деревья

В данной заметке я буду писать о двоичных (бинарных) деревьях.

## Графы. Базовые понятия

Чтобы понять, что такое бинарные деревья, необходимо начать с графов.

Базовые понятия:
**Граф** - это базовое понятие. Включает множество вершин и множество рёбер. Каждое ребро в графе соединяет две вершины.
**Вершина (узел)** - базовое понятие. Точка, куда могут вести или выходить рёбра. Множество вершин графа G обозначается
V(G).
**Ребро** - базовое понятие. Ребро соединяет две вершины графа
**Дуга** - ориентированное ребро. Если есть две вершины (v, w), то дуга может вести только из v -> w или же из w -> v,
то есть одна из вершин - начало дуги, а другая - конец. Однако, часто понятия ребро и дуга взаимозаменяются

Вес ребер:
**Вес ребра** - значение, поставленное в соответствие данному ребру взвешенного графа. Обычно вес — вещественное число,
в таком случае его можно интерпретировать как «длину» ребра.
**Взвешенный граф** - граф, каждому ребру которого назначен вес ребра

Петли и циклы:
**Петля** - ребро, начало и конец которого находятся в одной и той же вершине
**Цикл** - путь длины не менее 1, который начинается и заканчивается в одной и той же вершине
**Ациклический граф** - граф без циклов

Инцидентность и смежность (это об отношениях ребен и вершин):
**Инцидентность** - означает, что если есть вершины u1, u2 и соединяющее их ребро e, тогда вершина u1 и ребро e
инцидентны, как и вершина u2 с ребром e. Важно, что две вершины инцидентны быть не могут. Для обозначения ближайших
вершин (рёбер) используется понятие смежности.
**Смежность** - понятие, используемое в отношении только двух рёбер либо только двух вершин: два ребра, инцидентные
одной вершине, называются смежными; две вершины, инцидентные одному ребру, также называются смежными.
**Степень вершины** — количество рёбер, инцидентных вершине
**Степень захода вершины** - количество ребер, входящих в вершину
**Степерь исхода вершины** - количество ребер, исходящих из вершины

Связность (это о путях):
**Связность** - две вершины в графе связаны, если существует соединяющий их путь.
**Связный граф** — граф, в котором все вершины связаны.
**Компонента связности графа** — такое подмножество вершин графа, для любых двух вершин которого существует путь из
одной в другую, и не существует пути из вершины этого подмножества в вершину не из этого подмножества.

Путь и цикл:
**Простой путь** — путь, все вершины которого попарно различны. Другими словами, простой путь не проходит дважды через
одну вершину.
**Простой цикл** — цикл, не проходящий дважды через одну вершину.
**Расстояние между вершинами** — длина кратчайшего пути между двумя вершинами

Ориентированный граф:
**Орграф (ориентированный граф, directed grapgh)** - граф, в котором все ребра ориентированы (есть только дуги)
**Ориентированный ациклический граф (directed acyclic graph, DAG)** - ориентированный граф, в котором отсутствуют циклы,
но могут быть «параллельные» пути, выходящие из одного узла и разными путями приходящие в конечный узел

Понятия на будущее:
**Гамильтонов путь** — простой путь в графе, содержащий все вершины графа ровно по одному разу.
**Гамильтонов граф** — граф, в котором есть гамильтонов цикл.
**Эйлеров цийл** — цикл, который содержит все рёбра графа (вершины могут повторяться).
**Эйлеров граф** — граф, в котором существует эйлеров цикл

## Дерево

Итак, мы выучили все базовые понятия, теперь можем перейти к деревьям:
**Дерево** — это связный ациклический граф. Связность означает наличие маршрута между любой парой вершин, ацикличность —
отсутствие циклов. Отсюда следует, что число рёбер в дереве на единицу меньше числа вершин, а между любыми парами вершин
имеется один и только один путь
**Ориентированное дерево** - Ориентированный ациклический граф (DAG), в котором только одна вершина имеет нулевую
степень захода (в неё не ведут дуги), а все остальные вершины имеют степень захода 1 (в них ведёт ровно по одной дуге).
**Корень дерева** - выбранная вершина дерева. Или по-другому: вершина с нулевой степенью захода
**Лист дерева** - вершина дерева, из которого не исходит ни одна дуга, то есть вершина с нулевой ступеню исхода
**Высота дерева** - наибольшая длина пути от корня к листу

А вот лес, к слову:
**Лес** — множество деревьев. Или по-другому: неориентированный граф без циклов. Компонентами связности леса являются
деревья.

**Двоичное (бинарное) дерево** - это ориентированное дерево, в котором исходящие степени вершин (число исходящих рёбер)
не превосходят 2 Или более привычно и понятно:
**Двоичное (бинарное) дерево** - структура данных, в которой каждый узел имеет не более двух потомков. Как правило, этот
узел называется родительским узлом, а дети называются левым и правым наследниками.

Свойства дерева:

- Любое дерево с n вершинами содержит n−1 ребро

## Двоичное дерево поиска

**Двоичное дерево поиска (Binary Search Tree, BST)** - двоичное дерево, для которого выполняются следующие условия:

1. Оба поддерева — левое и правое — являются двоичными деревьями поиска;
2. У всех узлов левого поддерева произвольной вершины X значения ключей данных меньше, нежели значение ключа данных
   самого узла X;
3. У всех узлов правого поддерева произвольной вершины X значения ключей данных больше либо равны, нежели значение ключа
   данных самого узла X.

Очевидно, данные в каждом узле должны обладать ключами, на которых определена операция сравнения меньше.

Двоичное дерево поиска не следует путать с двоичной кучей, построенной по другим правилам. Ее мы рассмотрим позже.

Основным преимуществом двоичного дерева поиска перед другими структурами данных является возможная высокая эффективность
основанных на нём алгоритмов поиска и сортировки.

Сложность выполнения операций:

|       | В среднем | В худшем |
|---------------|:---------:|:--------:|
| Расход памяти |   O(n)    |   O(n)   |
| Поиск         | O(log n)  |   O(n)   |
| Вставка       | O(log n)  |   O(n)   |
| Удаление      | O(log n) |   O(n)   |

### Основные операции в двоичном дереве поиска

Базовый интерфейс двоичного дерева поиска состоит из трёх операций:

1. FIND(K) — поиск узла, в котором хранится пара (key, value) с key = K.
2. INSERT(K, V) — добавление в дерево пары (key, value) = (K, V).
3. REMOVE(K) — удаление узла, в котором хранится пара (key, value) с key = K.

По сути, двоичное дерево поиска — это структура данных, способная хранить таблицу пар (key, value). Двоичное дерево
поиска может использоваться в качестве имплементации словаря.

// todo можно ли обходить дерево поиска в ширину или имеет ли это смысл? почему на вики только обход в глубину

### Обход дерева

Обход дерева - это алгоритм посещения всех узлов в дереве по ровно одному разу. Данные алгоритмы классифицируются по
порядку обхода нод. Обход дерева бывает в глубину и ширину. Алгоритмы называются соответственно *DFS (depth-first
search)* и *BFS (
breadth-first search)*.

Почему вообще нужны эти алгоритмы обхода? Дело в том, что деревья сильно отличаются по устройству от таких линейных
структур данных как массивы, списки, которые обычно обходятся все линейном порядке. Но так как дерево не имеет четкого
порядка элементов, то есть каждая нода имеет несколько нод, куда можно пойти дальше, а не линейный порядок, то для этого
нам и нужны специальные алгоритмы обхода.

При обходе нам необходимо хранить отложенные на каждом уровне дерева ноды для их дальнейшего посещения. Для этих целей
часто используют стек (
stack) или очередь (queue). Однако, так как дерево - это self-referential (recursively defined) data structure, то обход
можно сделать с помощью рекурсии или даже корекурсии. В случае рекурсии мы храним отложенные ноды в call stack, а в
случае корекурсии мы вообще не заполняем стек. Корекурсия - это такая рекурсия, которая для дальнейшего вызова
использует данные, которая сама же и произвела, начиная с базового случая. Это не похоже на рекурсию, так как рекурсия
наоборот, использует полученных данные, в итоге приходя к базовому случая. Когда выполняется корекурсия, не происходит
заполнения call stack, так как нет необходимости хранить на каждом вызове текущие данные перед следующим вызовом
рекурсии. Например, вот рекурсивная функция для вычисления факториала:

```python
def factorial(n):
    """Recursive factorial function."""
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1) // 
```

Здесь мы храним n в call stack, чтобы затем умножить его на полученный от рекурсивного вызова результат.

Вот еще почитать про корекурсию

- https://edward-huang.com/functional-programming/algorithm/programming/scala/2020/08/02/wtf-is-corecursion/.

#### Обход в глубину

При обходе в глубину мы продвигаемся как можно глубже по дереву, прежде чем идти к следующему соседу. Для обхода в
глубину чаще всего используется рекурсивный метод и call stack.

Весь смысла обхода в глубину заключается в выполнении на каждой ноде следующих операций в определенной порядке:

1. Посещение текущей ноды (N)
2. Рекурсивно обойти левого потомка текущей ноды (L)
2. Рекурсивно обойти правого потомка текущей ноды (L)

Алгоритмы обхода в глубину:

1. Preorder (NLR)
2. Postorder (LRN)
3. Inorder (LNR)

Обход дерева на рисунке - красный - Pre-Order, зеленый - In-Order, синий - Post-order
![img.png](img.png)

#### Обход в ширину

## Куча

https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%87%D0%B0_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%BA%D1%83%D1%87%D0%B0
// todo

## Сбалансированные деревья

**Сбалансированные деревья (Self-balancing binary search tree)** - это такие бинарные деревья поиска, где поддерживается
правило, что уровень листьев отклоняется не более чем на 1

### Red-Black Tree (Красно-Черное дерево)

// todo

### AVL Tree

// todo