# Бинарные деревья

В данной заметке я буду писать о двоичных (бинарных) деревьях.

## Графы. Базовые понятия

Чтобы понять, что такое бинарные деревья, необходимо начать с графов.

Базовые понятия:
**Граф** - это базовое понятие. Включает множество вершин и множество рёбер. Каждое ребро в графе соединяет две вершины.
**Вершина (узел)** - базовое понятие. Точка, куда могут вести или выходить рёбра. Множество вершин графа G обозначается
V(G).
**Ребро** - базовое понятие. Ребро соединяет две вершины графа
**Дуга** - ориентированное ребро. Если есть две вершины (v, w), то дуга может вести только из v -> w или же из w -> v,
то есть одна из вершин - начало дуги, а другая - конец. Однако, часто понятия ребро и дуга взаимозаменяются

Вес ребер:
**Вес ребра** - значение, поставленное в соответствие данному ребру взвешенного графа. Обычно вес — вещественное число,
в таком случае его можно интерпретировать как «длину» ребра.
**Взвешенный граф** - граф, каждому ребру которого назначен вес ребра

Петли и циклы:
**Петля** - ребро, начало и конец которого находятся в одной и той же вершине
**Цикл** - путь длины не менее 1, который начинается и заканчивается в одной и той же вершине
**Ациклический граф** - граф без циклов

Инцидентность и смежность (это об отношениях ребен и вершин):
**Инцидентность** - означает, что если есть вершины u1, u2 и соединяющее их ребро e, тогда вершина u1 и ребро e
инцидентны, как и вершина u2 с ребром e. Важно, что две вершины инцидентны быть не могут. Для обозначения ближайших
вершин (рёбер) используется понятие смежности.
**Смежность** - понятие, используемое в отношении только двух рёбер либо только двух вершин: два ребра, инцидентные
одной вершине, называются смежными; две вершины, инцидентные одному ребру, также называются смежными.
**Степень вершины** — количество рёбер, инцидентных вершине
**Степень захода вершины** - количество ребер, входящих в вершину
**Степерь исхода вершины** - количество ребер, исходящих из вершины

Связность (это о путях):
**Связность** - две вершины в графе связаны, если существует соединяющий их путь.
**Связный граф** — граф, в котором все вершины связаны.
**Компонента связности графа** — такое подмножество вершин графа, для любых двух вершин которого существует путь из
одной в другую, и не существует пути из вершины этого подмножества в вершину не из этого подмножества.

Путь и цикл:
**Простой путь** — путь, все вершины которого попарно различны. Другими словами, простой путь не проходит дважды через
одну вершину.
**Простой цикл** — цикл, не проходящий дважды через одну вершину.
**Расстояние между вершинами** — длина кратчайшего пути между двумя вершинами

Ориентированный граф:
**Орграф (ориентированный граф, directed grapgh)** - граф, в котором все ребра ориентированы (есть только дуги)
**Ориентированный ациклический граф (directed acyclic graph, DAG)** - ориентированный граф, в котором отсутствуют циклы,
но могут быть «параллельные» пути, выходящие из одного узла и разными путями приходящие в конечный узел

Понятия на будущее:
**Гамильтонов путь** — простой путь в графе, содержащий все вершины графа ровно по одному разу.
**Гамильтонов граф** — граф, в котором есть гамильтонов цикл.
**Эйлеров цийл** — цикл, который содержит все рёбра графа (вершины могут повторяться).
**Эйлеров граф** — граф, в котором существует эйлеров цикл

## Дерево

Итак, мы выучили все базовые понятия, теперь можем перейти к деревьям:
**Дерево** — это связный неориентированный ациклический граф. Связность означает наличие маршрута между любой парой
вершин, ацикличность — отсутствие циклов. Отсюда следует, что число рёбер в дереве на единицу меньше числа вершин, а
между любыми парами вершин имеется один и только один путь
**Ориентированное дерево** - это связный ориентированный ациклический граф (DAG), в котором только одна вершина имеет
нулевую степень захода (корень), а все остальные вершины имеют степень захода 1 (в них ведёт ровно по одной дуге).
**Корень дерева** - выбранная вершина дерева. Или по-другому: вершина с нулевой степенью захода
**Лист дерева** - вершина дерева, из которого не исходит ни одна дуга, то есть вершина с нулевой степенью исхода
**Высота дерева** - наибольшая длина пути от корня к листу

Дерево как структура данных - это абстрактный тип данных, симулирующий структуру дерева - есть корень (root) и
поддеревья (subtrees). Каждый узел имеет не более одного родителя.

А вот это лес, к слову:
**Лес** — множество деревьев. Компонентами связности леса являются деревья.

**Двоичное (бинарное) дерево** - это ориентированное дерево, в котором исходящие степени вершин (число исходящих рёбер)
не превосходят 2. Или же, эквивалентно:
**Двоичное (бинарное) дерево** - структура данных, в которой каждый узел имеет не более двух детей. Как правило, сам
узел называется родительским узлом, а дети называются левым и правым наследниками.

Свойства дерева:

- Любое дерево с n вершинами содержит n−1 ребро

## Двоичное дерево поиска (BST)

**Двоичное дерево поиска (Binary Search Tree, BST)** - двоичное дерево, для которого выполняются следующие условия:

1. Оба поддерева — левое и правое — являются двоичными деревьями поиска;
2. У всех узлов левого поддерева произвольной вершины X значения ключей данных меньше, нежели значение ключа данных
   самого узла X;
3. У всех узлов правого поддерева произвольной вершины X значения ключей данных больше либо равны, нежели значение ключа
   данных самого узла X.

Очевидно, данные в каждом узле должны обладать ключами, на которых определена операция сравнения меньше.

Двоичное дерево поиска - это структура данных, которая может выступать в качестве имплементации некоторых АТД.  
Двоичное дерево поиска не следует путать с двоичной кучей, построенной по другим правилам. Ее мы рассмотрим позже.

Сложность выполнения операций:

|       | В среднем | В худшем |
|---------------|:---------:|:--------:|
| Расход памяти |   O(n)    |   O(n)   |
| Поиск         | O(log n)  |   O(n)   |
| Вставка       | O(log n)  |   O(n)   |
| Удаление      | O(log n) |   O(n)   |

### Основные операции в двоичном дереве поиска

Базовый интерфейс двоичного дерева поиска состоит из трёх операций:

1. FIND/LOOKUP(K) — поиск узла, в котором хранится пара (key, value) с key = K.
2. INSERT(K, V) — добавление в дерево пары (key, value) = (K, V).
3. REMOVE(K) — удаление узла, в котором хранится пара (key, value) с key = K.

По сути, двоичное дерево поиска — это структура данных, способная хранить таблицу пар (key, value). Двоичное дерево
поиска может использоваться в качестве имплементации словаря.

Вот как можно имплементировать эти операции:
LOOKUP - алгоритм:

- Если дерево пусто, сообщить, что узел не найден, и остановиться.
- Иначе сравнить K со значением ключа корневого узла X.
    - Если K=X, выдать ссылку на этот узел и остановиться.
    - Если K>X, рекурсивно искать ключ K в правом поддереве Т.
    - Если K<X, рекурсивно искать ключ K в левом поддереве Т.

INSERT - алгоритм:

- Если дерево пусто, заменить его на дерево с одним корневым узлом ((K, V), null, null) и остановиться.
- Иначе сравнить K с ключом корневого узла X.
    - Если K>X, рекурсивно добавить (K, V) в правое поддерево Т.
    - Если K<X, рекурсивно добавить (K, V) в левое поддерево Т.
    - Если K=X, заменить V текущего узла новым значением.

REMOVE - алгоритм:
Алгоритм:

- Если дерево T пусто, остановиться;
- Иначе сравнить K с ключом X корневого узла n.
    - Если K>X, рекурсивно удалить K из правого поддерева Т;
    - Если K<X, рекурсивно удалить K из левого поддерева Т;
    - Если K=X, то необходимо рассмотреть три случая.
        - Если обоих детей нет, то удаляем текущий узел и обнуляем ссылку на него у родительского узла;
        - Если одного из детей нет, то значения полей ребёнка m ставим вместо соответствующих значений корневого узла,
          затирая его старые значения, и освобождаем память, занимаемую узлом m;
        - Если оба ребёнка присутствуют, то
            - Если левый узел m правого поддерева отсутствует (n->right->left)
                - Копируем из правого узла в удаляемый поля K, V и ссылку на правый узел правого потомка.
            - Иначе
                - Возьмём самый левый узел m, правого поддерева n->right;
                - Скопируем данные (кроме ссылок на дочерние элементы) из m в n;
                - Рекурсивно удалим узел m.

#### Обход двоичного дерева поиска

In-order dfs обход двоичного дерева поиска позволяет обойти элементы дерева в неубывающем порядке ключей, что можно
использовать для сортировки. Если же использовать preorder dfs, то это позволяет нам вывести элемента дерева в порядке в
соответствии с устройством дерева.

Другие варианты обхода нам не интересны, так как не дают полезного порядка.

#### Применение BST

Основным преимуществом двоичного дерева поиска перед другими структурами данных является возможная высокая эффективность
основанных на нём алгоритмов поиска и сортировки.

BST позволяют сделать быстрые за O(log n) операции поиска, добавления и удаления данных. BST может использоваться для:

1. Имплементации таких абстрактных типов данных как сет, мультисет и мапа
2. Сортировки Tree Sort, которая основана на BST

Время log n исходит из того, что для поиска, добавления или удаления на каждом вызове рекурсии мы постоянно снижаемся
ниже по дереву, что в среднем случае занимает ровно столько шагов, сколько уровней в дереве. Понятно, что так как дерево
не сбалансированное, то bst может деградировать в односвязный список, что в худшем случае приводит к времени O(n).

По сути, можно сказать, что поиск в двоичном дереве поиска - это binary search.

## Применение дерева

- Дерево часто используется в качестве Abstract Syntax Tree (AST, помнишь, ты писал парсер?)
  ![img_2.png](img_2.png)

Тогда для AST:

- Pre-order обход позволяет сделать префиксную нотацию (Polish notation) - `+ 3 4`
- Post-order обход позволяет сделать постфиксную нотацию (Reverse Polish notation) - `3 4 +`. Такое выражение легко
  превращается в машинный код, чтобы далее выполнить этот код стек машиной
- In-order обход позволяет вывести элементы дерева в том порядке, который соответствует устройству дерева. Например, для
  BST это может использоваться для вывода элементов в соответствии с установленным компаратором (элемент в узле больше
  чем все элементы в левом поддереве и меньше чем все элементы в правом поддереве).

- Дерево используется как структура данных в виде, например, BST или Heap.
- Устройство файловых систем
- Деревья поиска

## Обход дерева

Обход дерева - это алгоритм посещения всех узлов в дереве по ровно одному разу. Данные алгоритмы классифицируются по
порядку обхода нод. Обход дерева бывает в глубину и ширину. Алгоритмы называются соответственно *DFS (depth-first
search)* и *BFS(breadth-first search)*.

Почему вообще нужны эти алгоритмы обхода? Дело в том, что деревья сильно отличаются по устройству от таких линейных
структур данных как массивы b списки, которые обычно обходятся все линейном порядке. Но так как дерево не имеет четкого
порядка элементов, то есть каждая нода имеет несколько нод, куда можно пойти дальше, а не линейный порядок, то для этого
нам и нужны специальные алгоритмы обхода.

При обходе нам необходимо хранить отложенные на каждом уровне дерева ноды для их дальнейшего посещения. Для этих целей
часто используют стек (stack) или очередь (queue). Однако, так как дерево - это self-referential (recursively defined)
data structure, то обход можно сделать с помощью рекурсии или даже корекурсии. В случае рекурсии мы храним отложенные
ноды в call stack, а в случае корекурсии мы вообще не заполняем стек. Корекурсия - это такая рекурсия, которая для
дальнейшего вызова использует данные, которая сама же и произвела, начиная с базового случая. Это не похоже на рекурсию,
так как рекурсия наоборот, использует полученных данные, в итоге приходя к базовому случая. Когда выполняется
корекурсия, не происходит заполнения call stack, так как нет необходимости хранить на каждом вызове текущие данные перед
следующим вызовом рекурсии. Например, вот рекурсивная функция для вычисления факториала:

```python
def factorial(n):
    """Recursive factorial function."""
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1) // 
```

Здесь мы храним переменную n в call stack, чтобы затем умножить ее на полученный от рекурсивного вызова результат.

Вот еще почитать про корекурсию

- https://edward-huang.com/functional-programming/algorithm/programming/scala/2020/08/02/wtf-is-corecursion/.

### Обход в глубину

При обходе в глубину мы продвигаемся как можно глубже по дереву, прежде чем идти к следующему соседу. Для обхода в
глубину чаще всего используется рекурсивный метод и call stack, но возможна и итеративная имплементация с явным
созданием стека.

Анимация работы алгоритма:
![](Animated-Depth-First-Search.gif)

Весь смысла рекурсивного обхода в глубину заключается в выполнении на каждой ноде следующих операций в определенной
порядке:

1. Посещение текущей ноды (N)
2. Рекурсивно обойти левого потомка текущей ноды (L)
2. Рекурсивно обойти правого потомка текущей ноды (L)

Виды обхода в глубину:

1. Preorder (NLR)
2. Postorder (LRN)
3. Inorder (LNR)

Обход дерева на рисунке - красный - Pre-Order, зеленый - In-Order, синий - Post-order
![img.png](img.png)

#### Применение DFS

- Нахождение компонент связности
- Топологическая сортировка

### Обход в ширину

В обходе в ширину дерево обходит сначала все ноды на текущем уровне дерева слева направо, прежде чем углубляться на
нижний уровень. Вот порядок, в котором будет обойдено дерево:
![img_3.png](img_3.png)

Анимация, показывающая работу алгоритма BFS (черные - посещенные, серые - поставленные в очередь):
![](Animated_BFS.gif)

Для имплементации обхода в ширину используется очередь, работающая по принципу FIFO.

Обход в ширину обычно имплементируется как non-recursive алгоритм. Non-recursive алгоритм bfs отличается от
non-recursive dfs следующим:

1. Используется очередь (FIFO) вместо стека (LIFO)
2. Проверяется, не был ли посещен текущий узел прежде чем класть его в очередь, в отличии от dfs, где эта проверка
   производится уже после взятия элемента из стека

То есть, смотри как интересно: заменяя очередь в BFS на стек, мы получаем DFS.

Принцип работы заключается в том, что при посещении каждой ноды мы кладем ее левого, а затем правого потомка в очередь,
помечаем ноду как посещенную и берем следующий элемент из очереди, повторяя те же самые действия с ним. Так как очередь
работает по принципу FIFO, то мы знаем, что при взятии элемента из очереди, мы берем самый ранний встретившийся элемент,
то есть встретившийся на как можно более высоком уровне. Это означает, что мы не уйдем с текущего уровня дерева, пока не
обойдем все элементы на нем.

Помечать ноды как посещенные нам нужно для того, чтобы не обойти узел по несколько раз. А это может быть в графе. Так
как только дерево по определению не содержит циклом, но граф может содержать цикл.

#### Применение BFS

- Нахождение наикратчайшего пути между двумя нодами

## Backtracking

// todo

## Куча

// todo

https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%87%D0%B0_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%BA%D1%83%D1%87%D0%B0

## Binary Tree Visualizer

Прикольный сайт, где можно поиграться с двоичными деревьями.

## Сбалансированные деревья

**Сбалансированные деревья (Self-balancing binary search tree)** - это такие бинарные деревья поиска, где поддерживается
правило, что уровень поддеревьев различается не более чем на 1.

### Red-Black Tree (Красно-Черное дерево)

// todo

### AVL Tree

// todo